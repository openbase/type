package rst.kitchen.hob;

option java_outer_classname = "MieleHobMessageType";
//option java_package = "MieleHobMessageType";
//option java_package = "de.miele.kognihome.mieleappliances.devices.hob";


/************************************************************************************************************
 *                                                                                                          *
 * USE BY AUTHORIZED STAFF ONLY!!!      EXTERNAL CONTROL MODE IS NOT SAFE!!                                 *
 *                                                                                                          *
 * DataObject for interfacing the Miele hob KM6352 enhanced with an external control interface              *
 * WARNING: The Miele devices with external control are manipulated laboratory devices and not safe!        *
 *                                                                                                          *
 * USE BY AUTHORIZED STAFF ONLY!!!                                                                          *
 *                                                                                                          *
 * @author Stefan Rüther                                                                                    *
 *      stefan.ruether@miele.de                                                                             *
 *                                                                                                          *
 ************************************************************************************************************
 */
 
//TODO 
//- finish datypes
//- is there any hob identifier, such as IP adress?

message MieleHobMessage
{
	optional HobState 			state 				= 1;
	optional HobFailure 		failure 			= 2;
	optional HobInformation		info				= 3;
	repeated CookingZoneStatus 	cookingZoneStatus 	= 4; 

}
	
// Hauptzustand des Kochfeldes:
	enum HobState{
							// Datenbyte[0], Werte, Beschreibung, CECED – Zustand
	  	STANDBY 			= 1; 	//  2 Hauptsensor betätigt, keine Kochstelle aktiv (Timeout 10s/30s), Stand By 
	  	RUNNING 			= 2; 	//  5 mindestens 1 Kochstelle aktiv, Running 
	  	FAILURE 			= 3; 	//  8 Fehler kein Betrieb möglich, Failure 
	  	SERVICE 			= 4; 	// 12 Kunden- bzw. Kundendienstdienstzugang, Service, 
	  	POWEROFF			= 5;	// 13 Kochfeld ist aus, keine LED ist an! Off 
	  	LOCKED 				= 6; 	// 31 Kochfeld ist aus und kann nicht eingeschaltet werden., Locked 
	  	STOPANDGO			= 7;  	// 39 STOP&GO Funktion aktiv, STOP&GO
	  	NOT_SET 			= 8; 	// State of RSB-Application's connection with the hob  
	}

// Allgemeine Kochfeld Fehler:
// Datenbyte 5 Bitfeld, Beschreibung (Bit[0]=LSB, Bit[7]=MSB);
message HobFailure 
{
   	optional bool longtime		= 1 [default = false]; 	// bit 1 Langzeitfehler 
   	optional bool adjustment	= 2 [default = false]; 	// bit 2 Abgleichfehler
   	optional bool hardware 		= 3 [default = false]; 	// bit 3 Hardwarefehler 
}

// Allgemeine Kochfeld Informationen:
// Datenbyte 6 Bitfeld, Beschreibung
message HobInformation
{
	optional bool secondControl 	= 1 [default = false]; 	// bit 0 LSB Second Control 
	optional bool localControl 		= 2 [default = false]; 	// bit 1 Local Control (Inverse Logik: 0==LocalControl; 1==kein Local Control) 
	optional bool stopState 		= 3 [default = false]; 	// bit 2 STOP-Zustand (alle Kochstellen auf 1) 
	optional bool hobLocked 		= 4 [default = false]; 	// bit 3 Kochfeld Verriegelt 
	optional bool doublePower 		= 5 [default = false]; 	// bit 4 Leistungsstufenverdoppelung aktiv 0,1,1.5,2,2.5,3 -> 0,1,2,3,4, 
	optional bool modeFair 			= 6 [default = false]; 	// bit 5 Messebetrieb 
	optional bool numberOfPowerLevels 	= 7 [default = false]; 	// bit 6 Anzahl der Leistungsstufen pro Kochzone (0 entspricht 9 Leistungsstufen, 1 entspricht 12 Leistungsstufen) 
}


message  CookingZoneStatus
{
	//@constraint(1 <= value <= 6)
  	required uint32 id				  = 1; 	// Kochfeld Nummer 
	optional CookingZonePowerLevel powerLevel = 2;
	optional CookingZoneInfo info 	  = 3;
	optional CookingZoneError error   = 4;
	optional CookingZoneTime startTime = 5; 
	optional CookingZoneTime endTime   = 6; 
}


/*
 * 	CookingZonePowerLevel
 * Note: setting one of the boolean fields will override the uint powerlevel!
 */
message CookingZonePowerLevel
{
	optional bool poweroff 				= 2; 	// Ausgeschaltet 
	optional uint32 powerLevel			= 3; 	// 1 – 23 Leistungsstufe 
					// entspricht immer der Knebelstellung am Kochfeld): 1-9 (12) 
					// falls Leistungsstufenverdopplung nicht aktiv (Byte 6, Bit 4 = 0) / 1-17 (23) 
					// falls Leistungsstufenverdopplung aktiv (Byte 6, Bit 4 = 1) 
	optional bool residual_Heat_H 			= 4; 	// 100 Restwärme H 
	optional bool residual_Heat_1 			= 5; 	// 101 Restwärme 1 
	optional bool residual_Heat_2 			= 6; 	// 102 Restwärme 2 
	optional bool residual_Heat_3 			= 7; 	// 103 Restwärme 3 
	optional bool residual_Heat_H_blinking	= 8; 	// 100 Restwärme H blinkend
	optional bool residual_Heat_1_blinking	= 9;	// 101 Restwärme 1 blinkend
	optional bool residual_Heat_2_blinking  = 10; 	// 102 Restwärme 2 blinkend
	optional bool residual_Heat_3_blinking	= 11; 	// 103 Restwärme 3 blinkend
	optional bool keeping_warm 				= 12; 	// bit 4 Leistungsstufenverdoppelung aktiv 0,1,1.5,2,2.5,3 -> 0,1,2,3,4, 

	
	//TODO
	// Startzeit Kochstelle:
	// Datenbyte 26 (Bit 7,6; Bit 0-5) ; Datenbyte 27 
	// (0,0 Relativ; Minuten 0-59); Stunden 0 – 255 
	// (0,1 Absolut; Minuten 0-59); Stunden 0 – 23
	
	//TODO
	// Dauer bzw. Endezeit Kochstelle:
	// Datenbyte 28 (Bit 7,6; Bit 0-5); Datenbyte 29 
	// (0,0 Relativ Minuten 0-59); Stunden 0 – 255 
	// (0,1 Absolut Minuten 0-59); Stunden 0 – 23 
}


message CookingZoneInfo 
{
	// Informationen Kochstelle:
	// Datenbyte 9 Bitfeld, Beschreibung
	optional bool AutoHeatUp 				= 1; 	// bit 0 LSB Ankochautomatik aktiv 
	optional bool versatileZoneOneActive  	= 2;	// bit 1 Variokochzone 1 aktiv
	optional bool versatileZoneTwoActive  	= 3;	// bit 2 Variokochzone 2 aktiv 
	optional bool panDetected 				= 4;	// bit 3 Topf erkannt 
	optional bool panSizeVersatileZoneOne 	= 5;	// bit 4 Topfgröße erkannt Variokochzone 1 	
	optional bool panSizeVersatileZoneTwo 	= 6;	// bit 5 Topfgröße erkannt Variokochzone 2 
	
	// @constraint(0<=value<=3)
	optional uint32 boosterFunction			= 7;	// bit 6,7 Booster Funktion: [0,0 läuft nicht; 0,1 Stufe 1; 1,0 Stufe 2; 1,1 Stufe 3] 
}

message CookingZoneError 
{
	// Fehler / Hinweise Kochstelle:
	// Datenbyte 10 Bitfeld, Beschreibung, 
	optional bool errorPanDetectionCoil		= 1; 	// bit 0 LSB Fehler Topferkennungsschleife 
	optional bool errorOperationTimeLimit	= 2; 	// bit 1 Betriebsdauerbegrenzung 
	optional bool infoMemoryFunction		= 3;	// bit 2 Kochstelle läuft über Memoryfunktion 
	optional bool infoPowerLimitActive		= 4;	// bit 3 Induktion Leistungsbegrenzung aktiv Es wird weiterhin der eingestellte max. Wert übertragen. 
}

message CookingZoneTime
{		
	// @constraint(value==1: "absolute", value==0: "relative")		
	optional bool absolute = 1; // relative or absolute time
	// @unit(minutes)
	// @constraint(0<=value<=59)
	optional uint32 minutes = 2; // 0-59 Minuten 
	// @unit(hours)
	// @constraint(0<=value<=23)
	optional uint32 hours = 3; 	// 0-23 Stunden
}

//TODO ist das überhaupt relevant?
// Kurzzeit: 
// message ShortTime
// {						// Datenbyte 1-3 Wertigkeit, Beschreibung
	// @unit(second)
	// @constraint(0<=value<=59)
// 	optional uint32 seconds = 1; // 0-59 Sekunden 
	// @unit(minutes)
	// @constraint(0<=value<=59)
// 	optional uint32 minutes = 2; // 0-59 Minuten 
	// @unit(hours)
	// @constraint(0<=value<=255)
// 	optional uint32 hours = 3; 	// 0-255 Stunden
// }





//IGNORE 
// Temperatur Simulation Ist Temperatur:
// Datenbyte 56 Ist Temperatur High Byte
// Datenbyte 57 Ist Temperatur Low Byte

//IGNORE 
// Temperatur Simulation Soll Temperatur:
// Datenbyte 58 Soll Temperatur High Byte
// Datenbyte 59 Soll Temperatur Low Byte


